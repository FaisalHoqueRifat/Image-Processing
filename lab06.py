# -*- coding: utf-8 -*-
"""Lab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vKOHEF9KTzJhpNSMYo1LY0DRcN_yB_JM
"""

# ===============================
# IMAGE PROCESSING TASK (Colab)
# ===============================

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

# -------------------------------
# STEP 1: Upload and read exactly 2 images
# -------------------------------
print("üì∏ Please upload your 2 images")
uploaded = files.upload()

if len(uploaded) != 2:
    print("‚ö†Ô∏è Please upload exactly 2 images.")
else:
    filenames = list(uploaded.keys())
    img1 = cv2.imread(filenames[0], cv2.IMREAD_GRAYSCALE)
    img2 = cv2.imread(filenames[1], cv2.IMREAD_GRAYSCALE)

    # Resize to same shape if different
    h = min(img1.shape[0], img2.shape[0])
    w = min(img1.shape[1], img2.shape[1])
    img1 = img1[:h, :w]
    img2 = img2[:h, :w]

    # Display uploaded images
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1); plt.imshow(img1, cmap='gray'); plt.title(filenames[0]); plt.axis('off')
    plt.subplot(1,2,2); plt.imshow(img2, cmap='gray'); plt.title(filenames[1]); plt.axis('off')
    plt.show()

    # ====================================================
    # TEMPORAL PROCESSING
    # ====================================================

    add_img = np.clip(img1.astype(int) + img2.astype(int), 0, 255).astype(np.uint8)
    sub_img = np.clip(img1.astype(int) - img2.astype(int), 0, 255).astype(np.uint8)
    mul_img = np.clip((img1.astype(float) * 1.5), 0, 255).astype(np.uint8)
    avg_img = ((img1.astype(int) + img2.astype(int)) // 2).astype(np.uint8)
    and_img = np.bitwise_and(img1, img2)
    or_img = np.bitwise_or(img1, img2)
    xor_img = np.bitwise_xor(img1, img2)

    titles = ['Image 1', 'Image 2', 'Add', 'Subtract', 'Multiply', 'Average', 'AND', 'OR', 'XOR']
    imgs = [img1, img2, add_img, sub_img, mul_img, avg_img, and_img, or_img, xor_img]

    plt.figure(figsize=(15,8))
    for i in range(len(imgs)):
        plt.subplot(3,3,i+1)
        plt.imshow(imgs[i], cmap='gray')
        plt.title(titles[i])
        plt.axis('off')
    plt.tight_layout()
    plt.show()

    # ====================================================
    # GEOMETRIC PROCESSING
    # ====================================================

    def rotate_image(img, angle):
        rad = np.deg2rad(angle)
        h, w = img.shape
        new_img = np.zeros_like(img)
        cx, cy = w//2, h//2
        for y in range(h):
            for x in range(w):
                x_shift = x - cx
                y_shift = y - cy
                new_x = int(cx + x_shift*np.cos(rad) - y_shift*np.sin(rad))
                new_y = int(cy + x_shift*np.sin(rad) + y_shift*np.cos(rad))
                if 0 <= new_x < w and 0 <= new_y < h:
                    new_img[y, x] = img[new_y, new_x]
        return new_img

    def zoom_image(img, zoom_factor):
        h, w = img.shape
        new_h, new_w = int(h * zoom_factor), int(w * zoom_factor)
        zoomed = np.zeros((new_h, new_w), dtype=np.uint8)
        for y in range(new_h):
            for x in range(new_w):
                src_y = int(y / zoom_factor)
                src_x = int(x / zoom_factor)
                zoomed[y, x] = img[src_y, src_x]
        return zoomed

    crop_img = img1[50:200, 50:200]
    rot_img = rotate_image(img1, 30)
    flip_h = img1[:, ::-1]
    flip_v = img1[::-1, :]
    zoom_img = zoom_image(img1, 1.5)
    shrink_img = zoom_image(img1, 0.5)

    titles2 = ['Original', 'Cropped', 'Rotated', 'Flip H', 'Flip V', 'Zoomed', 'Shrunk']
    imgs2 = [img1, crop_img, rot_img, flip_h, flip_v, zoom_img, shrink_img]

    plt.figure(figsize=(15,10))
    for i in range(len(imgs2)):
        plt.subplot(3,4,i+1)
        plt.imshow(imgs2[i], cmap='gray')
        plt.title(titles2[i])
        plt.axis('off')
    plt.tight_layout()
    plt.show()