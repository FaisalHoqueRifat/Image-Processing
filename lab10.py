# -*- coding: utf-8 -*-
"""Lab10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_JJ0R0ir50bJKu4v6cK0rRn8H-aSy0K7
"""

# ============================================================
#      FULL IMAGE COMPRESSION LAB (ONE FILE — COLAB READY)
# Huffman Coding | Arithmetic Coding | RLE | LZW | Block Coding
# ============================================================

from google.colab import files
from PIL import Image
import numpy as np
import io
import heapq
from collections import Counter
import matplotlib.pyplot as plt

# ============================================================
#                  IMAGE UPLOAD + DISPLAY
# ============================================================

print("=== Upload an image ===")
uploaded = files.upload()

filename = next(iter(uploaded))
image = Image.open(io.BytesIO(uploaded[filename])).convert("L")  # grayscale
image_np = np.array(image)

# Show image
plt.figure(figsize=(5,5))
plt.imshow(image_np, cmap="gray")
plt.title("Uploaded Image (Grayscale)")
plt.axis("off")
plt.show()

pixels = image_np.flatten().tolist()

print("Image loaded successfully!")
print("Image shape:", image_np.shape)
print("Total pixels:", len(pixels))


# ============================================================
#                     H U F F M A N
# ============================================================

class HuffmanNode:
    def __init__(self, value, freq):
        self.value = value
        self.freq = freq
        self.left = None
        self.right = None
    def __lt__(self, other):
        return self.freq < other.freq

def huffman_encode(data):
    freq = Counter(data)
    heap = [HuffmanNode(v, f) for v, f in freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        a = heapq.heappop(heap)
        b = heapq.heappop(heap)
        merged = HuffmanNode(None, a.freq + b.freq)
        merged.left = a
        merged.right = b
        heapq.heappush(heap, merged)

    # Generate codes
    root = heap[0]
    codes = {}

    def gen_code(node, cur):
        if node is None:
            return
        if node.value is not None:
            codes[node.value] = cur
        gen_code(node.left, cur + "0")
        gen_code(node.right, cur + "1")

    gen_code(root, "")
    encoded = "".join(codes[v] for v in data)

    return encoded, codes


huff_encoded, huff_codes = huffman_encode(pixels)
print("\n=== Huffman Coding ===")
print("Huffman encoded bits:", len(huff_encoded))
print("Unique Huffman codes:", len(huff_codes))


# ============================================================
#               A R I T H M E T I C   C O D I N G
# ============================================================

def arithmetic_encode(data):
    freq = Counter(data)
    total = sum(freq.values())

    # Build cumulative ranges
    ranges = {}
    low_val = 0.0

    for symbol, f in freq.items():
        high_val = low_val + f / total
        ranges[symbol] = (low_val, high_val)
        low_val = high_val

    L, H = 0.0, 1.0

    for symbol in data:
        sym_low, sym_high = ranges[symbol]
        interval = H - L
        H = L + interval * sym_high
        L = L + interval * sym_low

    return (L + H) / 2, ranges

arith_value, arith_ranges = arithmetic_encode(pixels)
print("\n=== Arithmetic Coding ===")
print("Arithmetic Encoded Value:", arith_value)


# ============================================================
#              R U N – L E N G T H   E N C O D I N G
# ============================================================

def rle_encode(data):
    out = []
    count = 1

    for i in range(1, len(data)):
        if data[i] == data[i - 1]:
            count += 1
        else:
            out.append((data[i - 1], count))
            count = 1
    out.append((data[-1], count))
    return out

rle_result = rle_encode(pixels)
print("\n=== RLE ===")
print("RLE length:", len(rle_result))


# ============================================================
#                         L Z W
# ============================================================

def lzw_encode(data):
    dictionary = {i: i for i in range(256)}  # pixel values dictionary
    current = data[0]
    result = []
    next_code = 256

    for pixel in data[1:]:
        key = current * 256 + pixel
        if key in dictionary:
            current = key
        else:
            result.append(dictionary[current])
            dictionary[key] = next_code
            next_code += 1
            current = pixel

    result.append(dictionary[current])
    return result

lzw_output = lzw_encode(pixels)
print("\n=== LZW ===")
print("LZW output length:", len(lzw_output))


# ============================================================
#                 B L O C K   C O D I N G
# ============================================================

def block_encode(data, block_size=8, out_size=4):
    bits = "".join(f"{p:08b}" for p in data)
    blocks = [bits[i:i+block_size] for i in range(0, len(bits), block_size)]
    return [b[:out_size] for b in blocks]  # cut to 4 bits (example)

block_result = block_encode(pixels)
print("\n=== Block Coding ===")
print("Block-coded blocks:", len(block_result))


# ============================================================
#                        SUMMARY
# ============================================================

print("\n============= SUMMARY =============")
print(f"Original Pixels:         {len(pixels)}")
print(f"Huffman Bit Length:      {len(huff_encoded)}")
print(f"RLE Entries:             {len(rle_result)}")
print(f"LZW Output Codes:        {len(lzw_output)}")
print(f"Block Coded Blocks:      {len(block_result)}")
print("====================================")