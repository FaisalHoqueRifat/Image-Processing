# -*- coding: utf-8 -*-
"""Lab12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1otdyRrUgpzcjCfjP4ZDIHVKAbHJfG4xg
"""

# ============================================================
# IMAGE PROCESSING LAB: Shape & Texture Features
# Freeman Chain Code | HOG | LBP | Skeleton | Convex Hull | Bounding Box
# Google Colab Ready - Upload your own image!
# ============================================================

# Install required libraries
!pip install opencv-python scikit-image matplotlib -q

import cv2
import numpy as np
from skimage import feature, morphology, measure
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
from google.colab import files
from collections import Counter
import warnings
warnings.filterwarnings('ignore')

print("=== UPLOAD YOUR IMAGE ===")
uploaded = files.upload()
filename = next(iter(uploaded))

# Read and preprocess image
img = cv2.imread(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Binarize using adaptive threshold for better contours
binary = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                              cv2.THRESH_BINARY_INV, 11, 2)

# Find contours
contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Select largest contour (main object)
if contours:
    largest_contour = max(contours, key=cv2.contourArea)
else:
    largest_contour = []

print(f"Found {len(contours)} contours. Using largest one.")
print("Image shape:", gray.shape)

# ============================================================
# 1. FREEMAN CHAIN CODE
# ============================================================
def freeman_chain_code(contour):
    """Convert contour to Freeman 8-direction chain code"""
    if len(contour) < 2:
        return []

    chain_code = []
    directions = [(0,1), (1,1), (1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1)]  # 0-7

    for i in range(1, len(contour)):
        prev_pt = contour[i-1][0]
        curr_pt = contour[i][0]
        dx = curr_pt[0] - prev_pt[0]
        dy = curr_pt[1] - prev_pt[1]

        # Find closest 8-direction
        angle = np.arctan2(dy, dx) * 180 / np.pi
        if angle < 0:
            angle += 360
        dir_idx = int((angle + 22.5) / 45) % 8
        chain_code.append(dir_idx)

    return chain_code

if largest_contour.size > 0:
    chain_code = freeman_chain_code(largest_contour)
    chain_freq = Counter(chain_code)
    print("\n=== 1. FREEMAN CHAIN CODE ===")
    print("Chain code length:", len(chain_code))
    print("Direction frequencies:", dict(chain_freq))
    print("Sample codes:", chain_code[:20], "...")
else:
    print("\n=== 1. FREEMAN CHAIN CODE === No contour found!")

# ============================================================
# 2. HISTOGRAM OF ORIENTED GRADIENTS (HOG)
# ============================================================
hog = cv2.HOGDescriptor()
hog_features = hog.compute(gray)
print("\n=== 2. HOG FEATURES ===")
print("HOG descriptor size:", hog_features.shape)
print("HOG mean:", np.mean(hog_features))
print("HOG std:", np.std(hog_features))

# Visualize HOG (small patch)
patch_hog = cv2.HOGDescriptor((64,64),(16,16),(8,8),(8,8),9)
patch = cv2.resize(gray, (64,64))
hog_patch = patch_hog.compute(patch)

# ============================================================
# 3. LOCAL BINARY PATTERN (LBP)
# ============================================================
lbp = feature.local_binary_pattern(gray, P=8, R=1, method='uniform')
lbp_hist, _ = np.histogram(lbp.ravel(), bins=np.arange(0, 10), density=True)

print("\n=== 3. LOCAL BINARY PATTERN ===")
print("LBP image shape:", lbp.shape)
print("LBP histogram (uniform):", lbp_hist[:5])

# ============================================================
# 4. SKELETON
# ============================================================
binary_bool = binary > 0
skeleton = morphology.skeletonize(binary_bool)
skeleton_img = (skeleton * 255).astype(np.uint8)

print("\n=== 4. SKELETON ===")
print("Skeleton non-zero pixels:", np.count_nonzero(skeleton))

# ============================================================
# 5. CONVEX HULL
# ============================================================
if largest_contour.size > 0:
    hull = cv2.convexHull(largest_contour)
    hull_area = cv2.contourArea(hull)
    obj_area = cv2.contourArea(largest_contour)
    print("\n=== 5. CONVEX HULL ===")
    print("Hull vertices:", len(hull))
    print("Hull area:", hull_area)
    print("Original area:", obj_area)
    print("Convexity:", obj_area / hull_area if hull_area > 0 else 0)
else:
    print("\n=== 5. CONVEX HULL === No contour!")

# ============================================================
# 6. BOUNDING BOX (Minimum Area Rectangle)
# ============================================================
if largest_contour.size > 0:
    rect = cv2.minAreaRect(largest_contour)
    box = cv2.boxPoints(rect)
    box = box.astype(np.int32) # Corrected from np.int0 to box.astype(np.int32)
    bbox_area = cv2.contourArea(largest_contour)

    print("\n=== 6. BOUNDING BOX ===")
    print("MinAreaRect center:", rect[0])
    print("Width, Height:", rect[1])
    print("Rotation angle:", rect[2])
    print("Bbox area ratio:", bbox_area / (rect[1][0] * rect[1][1]))
else:
    print("\n=== 6. BOUNDING BOX === No contour!")

# ============================================================
# VISUALIZATION
# ============================================================
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# Original and Binary
axes[0,0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[0,0].set_title('Original')
axes[0,0].axis('off')

axes[0,1].imshow(binary, cmap='gray')
axes[0,1].set_title('Binary')
axes[0,1].axis('off')

# Contour + Hull + Bbox
contour_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB).copy()
if largest_contour.size > 0:
    cv2.drawContours(contour_img, [largest_contour], -1, (0,255,0), 2)
    cv2.drawContours(contour_img, [hull], -1, (255,0,0), 2)
    cv2.drawContours(contour_img, [box], -1, (0,0,255), 2)

axes[0,2].imshow(contour_img)
axes[0,2].set_title('Contour (G), Hull (B), Bbox (R)')
axes[0,2].axis('off')

# Skeleton + Convex Hull
axes[1,0].imshow(skeleton_img, cmap='gray')
axes[1,0].set_title('Skeleton')
axes[1,0].axis('off')

hull_img = np.zeros_like(binary)
if largest_contour.size > 0:
    cv2.fillPoly(hull_img, [hull], 255)
axes[1,1].imshow(hull_img, cmap='gray')
axes[1,1].set_title('Convex Hull')
axes[1,1].axis('off')

# LBP Visualization (color-mapped)
axes[1,2].imshow(lbp, cmap='nipy_spectral')
axes[1,2].set_title('LBP (P=8,R=1)')
axes[1,2].axis('off')

plt.tight_layout()
plt.show()

# ============================================================
# SUMMARY TABLE
# ============================================================
print("\n" + "="*60)
print("LAB SUMMARY")
print("="*60)
if largest_contour.size > 0:
    print(f"Contour points: {len(largest_contour)}")
    print(f"Freeman chain length: {len(chain_code)}")
    print(f"Convexity (area ratio): {obj_area/hull_area:.3f}")
    print(f"Contour area: {obj_area:.0f} px")
print(f"HOG feature dim: {hog_features.shape[0]}")
print(f"LBP unique patterns: {len(np.unique(lbp))}")
print(f"Skeleton length: {np.count_nonzero(skeleton)} px")
print("="*60)